I need you to implement the next deliverable unit of work from the Kiro specs located in `.kiro/specs/`.

## Your Mission

Implement the **minimum set of tasks** that delivers a **testable, working unit** of functionality. Work incrementally, delivering small working pieces rather than attempting everything at once.

## Implementation Process

Work through the following phases systematically:

### Phase 1: Planning & Assessment

1. **Read the implementation order**: Start by reading `.kiro/specs/IMPLEMENTATION_ORDER.md` to understand:
   - Dependencies between specs
   - What's already complete
   - What can be done in parallel
   - What must be done sequentially
   - Current blockers

2. **Read the spec guide**: Read `claude-code-kiro-spec-prompt.md` to understand how to work with Kiro specifications

3. **Identify the next deliverable unit**: Based on IMPLEMENTATION_ORDER.md, determine:
   - What is the next logical unit of work?
   - What is the minimum set of tasks that delivers something testable?
   - Are there any blockers that must be resolved first?
   - Can any tasks be done in parallel?

4. **Analyze relevant specs**: For the spec(s) you'll work on, read in this order:
   - `requirements.md` - understand what needs to be built
   - `design.md` - understand how it should be built
   - `tasks.md` - see the implementation plan

5. **Verify completed tasks**: For all tasks marked complete `[x]`:
   - Check that the code actually exists
   - Verify it matches the requirements
   - Ensure it follows the design document
   - If anything is incomplete or incorrect, fix it before proceeding

6. **Announce your plan**: Before starting implementation, clearly state:
   - Which spec(s) you're working on
   - Which tasks you're implementing (minimum set for a deliverable unit)
   - Why this is the next logical step
   - What will be testable after completion

### Phase 2: Implementation

For the selected deliverable unit (minimum set of tasks):

1. **Implement the tasks** following the design document exactly

2. **Write tests** for the new functionality:
   - Unit tests for individual components
   - Integration tests for component interactions
   - E2E tests if appropriate for this deliverable

3. **Run comprehensive quality checks** before marking complete:
   ```bash
   # Run all tests
   uv run pytest -m "slow or not slow"

   # Run all tox quality checks
   tox -e ruff           # Python linting
   tox -e shellcheck     # Shell script linting
   tox -e docs           # Documentation checks

   # Run mypy for type checking
   uv run mypy src/doctk
   ```

4. **Fix ALL issues found**:
   - All tests must pass (zero failures)
   - All linting must pass (zero warnings/errors)
   - All type checking must pass (zero mypy errors)
   - All documentation checks must pass
   - Zero errors, zero warnings, zero issues

5. **Update documentation**:
   - Mark completed tasks in `tasks.md` with `[x]`
   - Update the spec's `design.md` if implementation revealed necessary changes
   - Update `.kiro/specs/IMPLEMENTATION_ORDER.md`:
     - Mark completed tasks with ✅
     - Update "Current Status" section
     - Update "Immediate next steps" if needed
     - Adjust dependency information if needed

6. **Verify the deliverable**: Confirm that:
   - The implemented unit is testable and working
   - All quality checks pass
   - Documentation is updated
   - The next person knows what to do next (from IMPLEMENTATION_ORDER.md)

### Phase 3: Delivery & Handoff

After completing the deliverable unit:

1. **Final verification**:
   - Run complete test suite: `uv run pytest -m "slow or not slow"`
   - Run all tox environments: `tox`
   - Run mypy type checking: `uv run mypy src/doctk`
   - Verify environment: `./scripts/check-environment.sh`

2. **Commit your work**:
   - Create a clear commit message describing what was delivered
   - Reference the spec and task numbers
   - Mention what is now testable/working

3. **Update tracking documents**:
   - Ensure `tasks.md` reflects completed work
   - Ensure `IMPLEMENTATION_ORDER.md` is current
   - Update any relevant README files

4. **Prepare for next iteration**:
   - Clearly state what was accomplished
   - Identify what should be done next (from IMPLEMENTATION_ORDER.md)
   - Note any blockers or dependencies for the next unit
   - Suggest the next minimum deliverable unit

## Quality Standards (CRITICAL)

Before marking ANY task as complete, ensure:
- ✅ All tests pass (unit, e2e, quality, docs) - zero failures
- ✅ All linting passes (ruff, shellcheck, shfmt, markdownlint) - zero warnings/errors
- ✅ All type checking passes (mypy) - zero errors
- ✅ All documentation builds successfully
- ✅ Code follows project conventions (see CLAUDE.md)
- ✅ Absolutely zero warnings, errors, or issues

## Mypy Configuration

If mypy is not configured in tox.ini, add this section:

```ini
[testenv:mypy]
description = Run mypy type checking
deps = mypy
commands = mypy src/doctk --strict
```

Then ensure it passes before marking tasks complete.

## Implementation Guidelines

- **Work incrementally**: Deliver small, testable units rather than attempting everything at once
- **Follow dependencies**: Always check IMPLEMENTATION_ORDER.md before starting work
- **Minimum viable deliverable**: Pick the smallest set of tasks that delivers something testable and working
- **Verify constantly**: Run quality checks after every significant change, not just at the end
- **Fix everything**: Address all warnings and errors immediately - don't accumulate technical debt
- **Follow design**: Implement exactly what's specified in design documents
- **Meet requirements**: Satisfy all acceptance criteria from requirements.md
- **Update all documentation**: Keep tasks.md, IMPLEMENTATION_ORDER.md, and design.md current
- **Be thorough**: Verify that tasks marked as complete are actually complete before proceeding
- **Enable the next person**: Leave clear documentation about what's done and what's next

## Project Context

The doctk project is a Python document manipulation toolkit with these characteristics:
- Uses `uv` for Python package management
- Uses `tox` for test orchestration and quality checks
- Follows strict quality standards (documented in CLAUDE.md)
- Values immutability, type safety, and composability
- Requires comprehensive testing and documentation for all code

## Getting Started

1. Read `.kiro/specs/IMPLEMENTATION_ORDER.md` to understand the current state and dependencies
2. Read the spec guide (`claude-code-kiro-spec-prompt.md`) to understand how to work with specs
3. Identify the next minimum deliverable unit based on IMPLEMENTATION_ORDER.md
4. Announce your plan before starting implementation
5. Implement, test, verify, document, and deliver

As you work, feel free to show your progress, ask questions if requirements are unclear, and share any issues you encounter. The goal is to deliver working, tested functionality incrementally while maintaining the project's high quality standards.

## Key Principle: Incremental Delivery

**Don't try to implement everything at once.** Instead:
- Pick the next logical unit from IMPLEMENTATION_ORDER.md
- Implement the minimum set of tasks that delivers something testable
- Verify it works completely
- Update all documentation (tasks.md, IMPLEMENTATION_ORDER.md, design.md)
- Commit and hand off
- Let the next iteration pick up the next unit

This approach ensures:
- Continuous progress with working, tested code
- Clear handoff points between work sessions
- Reduced risk of large, untested changes
- Better tracking of what's done and what's next
