# Architecture Decision Record: Core Integration Layer

**Status**: Accepted
**Date**: 2025-11-19
**Deciders**: Core Team
**Related Spec**: `.kiro/specs/doctk-core-integration`

## Context

The doctk project needed a robust integration layer to bridge the core document manipulation API with multiple user interfaces (VS Code extension, Language Server, CLI, future JupyterLab). This ADR documents the key architectural decisions made during the implementation of the core integration layer.

---

## Decision 1: Separate Integration Layer from UI-Specific Code

### Status: **ACCEPTED**

### Context

Originally, document operations were tightly coupled with the VS Code extension. This created duplication and made it difficult to support multiple interfaces.

### Decision

Create a platform-agnostic integration layer in `src/doctk/integration/` that is completely independent of any specific UI framework or protocol (LSP, VS Code API, etc.).

**Structure:**
```
src/doctk/
├── integration/      # Platform-agnostic (NEW)
│   ├── operations.py
│   ├── bridge.py
│   └── protocols.py
├── lsp/              # LSP-specific
├── dsl/              # DSL-specific
└── core.py           # Core API
```

### Consequences

**Positive:**
- ✅ Code reuse across interfaces
- ✅ Clear separation of concerns
- ✅ Easier testing (no UI dependencies)
- ✅ Future interfaces (JupyterLab, web) can reuse integration layer

**Negative:**
- ❌ Slightly more complex module structure
- ❌ Additional abstraction layer

**Status**: Widely adopted. All interfaces now use the integration layer successfully.

---

## Decision 2: Granular Edits Instead of Full Document Replacement

### Status: **ACCEPTED**

### Context

Initial implementation replaced entire documents after each operation, which:
- Disrupted cursor position in editors
- Broke undo/redo stack
- Caused flickering in large documents
- Poor user experience

### Decision

Implement `DiffComputer` to calculate precise text ranges modified by each operation, returning `ModifiedRange` objects with line/column positions.

**API Design:**
```python
@dataclass
class ModifiedRange:
    start_line: int
    start_column: int
    end_line: int
    end_column: int
    new_text: str

@dataclass
class OperationResult:
    success: bool
    document: str
    modified_ranges: list[ModifiedRange] | None  # NEW
    error: str | None
```

### Alternatives Considered

1. **Full document replacement** - Rejected due to poor UX
2. **Track changes at AST level** - Rejected as too complex
3. **Line-based diffs** - Rejected as imprecise
4. **Character-based diffs** - **Chosen** (most precise)

### Consequences

**Positive:**
- ✅ Cursor position preserved after operations
- ✅ Undo/redo stack preserved
- ✅ No visual flickering
- ✅ Better performance (smaller edits)
- ✅ Backward compatible (full document always included)

**Negative:**
- ❌ Increased implementation complexity
- ❌ Requires careful testing for correctness

**Status**: Successfully implemented and tested. All operations return granular ranges.

---

## Decision 3: Centralized Node ID Generation in Backend

### Status: **ACCEPTED**

### Context

Initial implementation generated node IDs in both frontend (TypeScript) and backend (Python), leading to:
- ID inconsistencies between operations
- Complex synchronization logic
- Difficult debugging

### Decision

Generate all node IDs in the backend only. Frontend requests tree structure via `get_document_tree()` RPC method.

**API Design:**
```python
@dataclass
class TreeNode:
    id: str              # Generated by backend ONLY
    label: str
    level: int
    line: int
    column: int
    children: list[TreeNode]

class DocumentTreeBuilder:
    def build_tree_with_ids(self) -> TreeNode:
        """Build tree with backend-generated IDs."""
        pass
```

### Alternatives Considered

1. **Frontend generates IDs** - Rejected due to sync issues
2. **IDs in both places** - Rejected due to duplication (original approach)
3. **Backend generates IDs** - **Chosen** (single source of truth)

### Consequences

**Positive:**
- ✅ Single source of truth for IDs
- ✅ Guaranteed consistency
- ✅ Simpler frontend logic
- ✅ Easier debugging

**Negative:**
- ❌ Extra RPC call to get tree
- ❌ Slightly higher latency (negligible in practice)

**Status**: Implemented and working well. No synchronization issues observed.

---

## Decision 4: Line Position Caching for Performance

### Status: **ACCEPTED**

### Context

Computing line positions for nodes was O(n²) because each operation traversed the document multiple times to find node positions. This caused severe performance issues with documents containing 1000+ headings (3.8s+ for tree building).

### Decision

Implement line position caching in `DocumentTreeBuilder.__init__()` via `_build_line_position_cache()`.

**Implementation:**
```python
class DocumentTreeBuilder:
    def __init__(self, document: Document[Node]):
        self.document = document
        self._line_position_cache: dict[int, int] = {}  # node_index -> line
        self._line_count_cache: dict[int, int] = {}     # node_index -> line_count
        self._build_node_map()
        self._build_line_position_cache()  # O(n) one-time cost
```

### Performance Impact

**Before:**
- Tree building: ~3.8s for 1000 headings
- Complexity: O(n²)

**After:**
- Tree building: <1s for 1000 headings ✅
- Complexity: O(n)
- Meets performance requirement (≤ 1s for 1000 headings)

### Consequences

**Positive:**
- ✅ Massive performance improvement (3.8s → <1s)
- ✅ Linear scaling instead of quadratic
- ✅ All performance benchmarks now pass

**Negative:**
- ❌ Slight memory overhead (2 caches)
- ❌ One-time O(n) initialization cost (acceptable)

**Status**: Implemented and validated. All performance tests pass.

---

## Decision 5: JSON-RPC Bridge for TypeScript-Python Communication

### Status: **ACCEPTED**

### Context

VS Code extension (TypeScript) needs to call Python backend for document operations. Need a robust, standard protocol.

### Decision

Use JSON-RPC 2.0 over stdin/stdout via `ExtensionBridge` class.

**Why JSON-RPC:**
- Industry standard protocol
- Well-defined error handling
- Request/response pattern
- Simple to implement
- Language-agnostic

**Implementation:**
```python
class ExtensionBridge:
    def handle_request(self, request: dict[str, Any]) -> dict[str, Any]:
        """Handle JSON-RPC 2.0 request."""
        method = request.get("method")
        params = request.get("params", {})
        # ... route to appropriate handler ...
```

### Alternatives Considered

1. **Direct Python subprocess calls** - Rejected (no protocol)
2. **HTTP API** - Rejected (overkill, latency)
3. **gRPC** - Rejected (too complex for needs)
4. **JSON-RPC** - **Chosen** (standard, simple)

### Consequences

**Positive:**
- ✅ Standard protocol
- ✅ Well-defined error handling
- ✅ Easy to debug (JSON is human-readable)
- ✅ Language-agnostic (can add other clients)

**Negative:**
- ❌ JSON serialization overhead (minor)
- ❌ No native streaming (not needed)

**Status**: Working reliably. No issues observed in production.

---

## Decision 6: DSL Separate from Integration Operations

### Status: **ACCEPTED**

### Context

Need a text-based DSL for scripting document transformations (REPL, script files, code blocks in Markdown).

### Decision

Create separate DSL layer (`src/doctk/dsl/`) with lexer, parser, and executor that *uses* the integration layer's `StructureOperations` rather than duplicating logic.

**Architecture:**
```
DSL Layer (dsl/)
    ↓ uses
Integration Layer (integration/operations.py)
    ↓ uses
Core API (core.py)
```

### Consequences

**Positive:**
- ✅ Single source of truth for operations
- ✅ DSL benefits from integration layer improvements
- ✅ Clear separation: DSL = syntax, Integration = semantics
- ✅ Easy to add new operations (one place)

**Negative:**
- ❌ DSL cannot directly manipulate AST (must go through integration)
- ❌ Known issue: Node IDs change after operations (see Future Improvements)

**Status**: Working well. Known limitation documented as Task 16 (post-MVP).

---

## Decision 7: Immutability Pattern for Document Operations

### Status: **ACCEPTED**

### Context

Document operations need to be predictable, testable, and safe for concurrent use.

### Decision

All operations return new `Document` instances rather than mutating in place.

**Pattern:**
```python
def promote(document: Document[Node], node_id: str) -> OperationResult:
    # Find node
    node = tree_builder.find_node(node_id)

    # Create NEW node (immutable)
    promoted_node = node.promote()

    # Create NEW document (immutable)
    new_nodes = list(document.nodes)
    new_nodes[node_index] = promoted_node
    new_document = Document(new_nodes)

    return OperationResult(success=True, document=new_document.to_string())
```

### Consequences

**Positive:**
- ✅ Predictable behavior
- ✅ Easy to test
- ✅ No side effects
- ✅ Safe for undo/redo
- ✅ Aligns with doctk core philosophy

**Negative:**
- ❌ Memory allocation for each operation
- ❌ Cannot efficiently chain multiple operations (see Task 16)

**Status**: Core principle. No plans to change.

---

## Decision 8: Pluggable Architecture with Abstract Interfaces

### Status: **ACCEPTED**

### Context

Need to support multiple UIs (VS Code, JupyterLab, web, CLI) without code duplication.

### Decision

Define abstract `DocumentInterface` protocol that all UIs must implement.

**Design:**
```python
class DocumentInterface(ABC):
    @abstractmethod
    def display_tree(self, tree: Any) -> None: pass

    @abstractmethod
    def get_user_selection(self) -> Any | None: pass

    @abstractmethod
    def apply_operation(self, operation: Any) -> OperationResult: pass

    @abstractmethod
    def show_error(self, message: str) -> None: pass
```

### Consequences

**Positive:**
- ✅ Clear contract for new interfaces
- ✅ Easy to add new UIs
- ✅ Type-safe (mypy checks compliance)
- ✅ Well-documented extension point

**Negative:**
- ❌ Additional abstraction
- ❌ Must implement all methods (even if not used)

**Status**: Successfully used for VS Code. Ready for future interfaces.

---

## Decision 9: Memory Management with LRU Cache

### Status: **ACCEPTED**

### Context

Language server may handle many documents simultaneously, risking memory exhaustion.

### Decision

Implement `DocumentStateManager` with LRU eviction policy and configurable memory limits.

**Implementation:**
```python
class DocumentStateManager:
    def __init__(self, max_cache_size: int = 100, max_memory_mb: int = 500):
        self.cache = LRUCache(max_size=max_cache_size)
        self.max_memory_mb = max_memory_mb

    def put_document(self, uri: str, doc: Document) -> None:
        # Check memory, evict if needed
        if self._check_memory_limit():
            self.cache.evict_lru()
        self.cache.put(uri, doc)
```

### Consequences

**Positive:**
- ✅ Bounded memory usage
- ✅ Automatic eviction
- ✅ Configurable limits
- ✅ Meets 500MB requirement

**Negative:**
- ❌ May need to reload evicted documents
- ❌ Requires psutil for accurate memory tracking (optional dependency)

**Status**: Implemented and tested. Memory limits enforced successfully.

---

## Decision 10: Performance Monitoring Infrastructure

### Status: **ACCEPTED**

### Context

Need to track operation performance to identify bottlenecks and verify requirements are met.

### Decision

Implement `PerformanceMonitor` class with context manager support for automatic timing.

**Implementation:**
```python
monitor = PerformanceMonitor(slow_threshold_ms=200.0)

with monitor.track("operation_name"):
    # Do work
    pass

# Get slow operations
slow_ops = monitor.get_slow_operations()
```

### Consequences

**Positive:**
- ✅ Easy to add timing to any operation
- ✅ Identifies performance bottlenecks
- ✅ Validates performance requirements
- ✅ Useful for debugging

**Negative:**
- ❌ Small overhead (negligible)
- ❌ Requires manual cleanup of old data

**Status**: Implemented and used in tests. Not yet enabled in production (opt-in).

---

## Known Limitations and Future Work

### Task 16: Separate Internal and External Operations

**Problem:** DSL executor uses `StructureOperations` (designed for JSON-RPC), causing:
- Node ID remapping on every operation
- Cannot chain operations in code blocks
- Unnecessary serialization overhead

**Solution (Post-MVP):**
1. Create `InternalOperations` that returns `Document` objects directly
2. Refactor `StructureOperations` as thin wrapper for JSON-RPC
3. Update DSL executor to use `InternalOperations`
4. Add stable node IDs to `Document`

**Priority:** P2 (important future improvement, not blocking MVP)

---

## Lessons Learned

1. **Caching is critical** - Line position caching reduced tree building from 3.8s to <1s
2. **Granular edits matter** - Users notice poor editor UX immediately
3. **Single source of truth** - Centralized node ID generation eliminated sync bugs
4. **Standard protocols work** - JSON-RPC provided robustness without complexity
5. **Immutability has tradeoffs** - Great for correctness, but limits chaining efficiency

---

## References

- [Core Integration Spec](../../.kiro/specs/doctk-core-integration/)
- [Pluggable Architecture Design](./02-pluggable-architecture.md)
- [Core Integration API](../api/core-integration.md)
- [DSL API Reference](../api/dsl.md)
- [Performance Benchmarks](../../tests/unit/test_performance_benchmarks.py)

---

## Approval

**Status**: Accepted and implemented
**Review Date**: 2025-11-19
**Reviewers**: Core team
**Next Review**: When considering Task 16 implementation
